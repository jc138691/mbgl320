package io.ace;

import io.fasta.FastaReader;
import io.fasta.FastaQltyReader;
import io.fasta.DnaFileReader;

import javax.utilx.log.Log;
import javax.swingx.textx.TextView;
import javax.swing.*;
import java.io.*;
import java.util.StringTokenizer;

import dna.contig.ContigArr;
import olga.SnpStation;

/**
 * Created by Dmitry.A.Konovalov@gmail.com, 09/10/2009, 2:21:24 PM
 */
public class AceReader extends DnaFileReader<AceContigArr> {
  public static Log log = Log.getLog(AceReader.class);
  private static final String AS_TAG = "AS";   // AS <number of contigs> <total number of reads in ace file>
  private static final int AS_N_TOKENS = 3;

  //see http://www.codoncode.com/support/consed_readme.htm

  //CO <currContig name> <# of bases> <# of reads in currContig> <# of base segments in currContig> <U or C>
  /**
   This defines the contig.  The U or C indicates whether the contig has
   been complemented from the way phrap originally created it.  Thus this
   is always U for an ace file created by phrap.

   The contig sequence follows.  It includes pads--"*" characters which
   are inserted by phrap in order to make room for some read that has an
   extra base at that position.  (Note: any position which counts the *'s is
   referred to as a "padded position".  A position that does not count
   *'s is referred to as "unpadded position".)
   */
  private static final String CONTIG_TAG = "CO";
  private static final int CONTIG_N_TOKENS = 6;

  /**
   BQ

   This starts the list of base qualities for the unpadded consensus
   bases.  (NB: annoyingly, no qualities are given for *'s in the
   consensus.)  The contig is the one from the previous CO, hence no name
   is needed here.
   */
  private static final String BASE_QLTY_TAG = "BQ";

  /**
   AF <read name> <C or U> <padded start consensus position>

   This defines the location of the read within the contig.
   C or U means complemented or uncomplemented.
   <padded start consensus position> means the position of the
   beginning of the read, in terms of consensus bases which start at 1
   and do count *'s.
   */
  private static final String AF_TAG = "AF";
  private static final String AF_C_CODE = "C";
  private static final int AF_N_TOKENS = 4;

  /**
   BS <padded start consensus position> <padded end consensus position> <read name>

   The BS line (base segment) indicates which read phrap has chosen to be
   the consensus at a particular position.

   If you are writing the ace file from an assembler other than phrap,
   and since most assemblers do not compute the consensus this way, you
   still must write BS lines for Consed's benefit.  In this case, I
   suggest you choose any read which matches the consensus perfectly over
   the stretch of bases.  There must not be any two BS lines that
   intersect.  Each unpadded base must be included in some BS line.
   */
  private static final String BS_TAG = "BS";     // ignored !!!!!!!!!!

  //   RD <read name> <# of padded bases> <# of whole read info items> <# of read tags>
  /**
   Below RD is the sequence of bases for the read.  The sequence includes
   *'s and is in the orientation that phrap needed to align it against
   the consensus (thus it might be complemented from the direction it was
   sequenced).
   */
  private static final String READ_TAG = "RD";
  private static final int READ_N_TOKENS = 5;


  /**
   QA <qual clipping start> <qual clipping end> <align clipping start> <align clipping end>

   This line indicates which part of the read is the high quality segment
   (if there is any) and which part of the read is aligned against the
   consensus.  These positions are offsets (and count *'s) from the left
   end of the read (left, as shown in Consed).  Hence for bottom strand
   reads, the offsets are from the end of the read.  The offsets are
   1-based.  That is, if the left-most base is in the aligned,
   high-quality region, <qual clipping start> = 1 and <align clipping
   start> = 1 (not zero).  If the entire read is low quality, then <qual
   clipping start> and <qual clipping end> will both be -1.
   */
  private static final String READ_QA_TAG = "QA";
  private static final int READ_QA_N_TOKENS = 5;

  /**
   DS CHROMAT_FILE: <name of chromat file> PHD_FILE: <name of phd file> TIME: <date/time of the phd file> CHEM: <prim, term, unknown, etc> DYE: <usually ET, big, etc> TEMPLATE: <template name> DIRECTION: <fwd or rev>

   This line must contain information that matches the phd file.  If you
   are writing an ace file, pay particular attention to this line.  Make
   sure that Consed can read your ace file without reporting any errors.

   There can be additional information on this line.
   This replaces the DESCRIPTION line from the old ace file.

   The following is for transient read tags (those generated by
   crossmatch and phrap).  They are not fully implemented, and the format
   may eventually change.  The read is implied by the location of the
   whole read info item within the ace file.  They are found after the DS
   line for a read.   */
  private static final String READ_DS_TAG = "DS";    // ignored !!!!!!!!!!

  private AceContig currContig = null;
  private static boolean foundOne;

  public ContigArr read(SnpStation project,  TextView view) {  //log.setDbg();
    return super.read("ACE", view, project.getAceOpt());
  }
  public AceContigArr makeResType() {
    return new AceContigArr();
  }
  public void init() {
    currContig = null;
  }
  public boolean readOne(BufferedReader from, TextView view, AceContigArr contigArr) throws IOException {
    if (from == null)
      return false;

    foundOne = false;
    AceRead currRead = null;
    for (int countIdx = 0;  !foundOne; countIdx++) {
      String s = from.readLine();    log.dbg("countIdx=", countIdx); log.dbg(s).eol();  //view.println(s); //log.info(s);
      if (s == null)  {   // end of file
        loadIfReady(currContig, contigArr);
        currContig = null;
        break;
      }
//      s = removeCppComments(s);
      s = s.trim();               log.dbg("s.trim()=", s); // remove whites
      if (s.length() == 0) {      log.dbg("s.length() == 0"); // ignore empty lines
        continue;
      }
      if (s.indexOf(AS_TAG) == 0) {     log.dbg("s.indexOf(AS_TAG) == 0");
        if (!loadAS(s, contigArr))
          return false;
      }
      else if (s.indexOf(CONTIG_TAG) == 0) {    log.dbg("s.indexOf(CONTIG_TAG) == 0");
        loadIfReady(currContig, contigArr);
        currContig = new AceContig(); // make fresh        
        if (!loadContig(s, currContig))
          return false;
        if (!FastaReader.loadBases(from, currContig.getConsens()))
          return false;
      }
      else if (s.indexOf(BASE_QLTY_TAG) == 0) {       log.dbg("s.indexOf(BASE_QLTY_TAG) == 0");
        if (!FastaQltyReader.loadQlty(from, currContig.getConsens()))
          return false;
      }
      else if (s.indexOf(AF_TAG) == 0) {     log.dbg("s.indexOf(AF_TAG) == 0"); //AF <read name> <C or U> <padded start consensus position>
        if (!loadAF(s, currContig))
          return false;
      }
      else if (s.indexOf(BS_TAG) == 0) {     log.dbg("s.indexOf(BS_TAG) == 0"); //BS <padded start consensus position> <padded end consensus position> <read name>
        if (!loadBS(s, currContig))
          return false;
      }
      else if (s.indexOf(READ_TAG) == 0) {  log.dbg("s.indexOf(READ_TAG) == 0");
        currRead = new AceRead();
        if (!loadRead(s, currRead))
          return false;
        if (!FastaReader.loadBases(from, currRead))
          return false;
        contigArr.addRead(currRead); // NOTE!! saving the source reads in the contigArr (not currContig)
      }
      else if (s.indexOf(READ_QA_TAG) == 0) {    log.dbg("s.indexOf(READ_QA_TAG) == 0");
        if (!loadReadQA(s, currRead))
          return false;
      }
      else if (s.indexOf(READ_DS_TAG) == 0) {    log.dbg("s.indexOf(READ_DS_TAG) == 0");
        if (!loadReadDS(s, currRead))
          return false;
      }
      else {
        String error = "Expecting \nAS <number of contigs> <total number of reads in ace file>:\nbut got\n" + s;
        log.error(error);
        JOptionPane.showMessageDialog(view, error);
        return false;
      }
    }
    return true;
  }
  private static void loadIfReady(AceContig contig, ContigArr contigs) {
    if (contig != null) {
      foundOne = true;          log.info("if (contig != null) foundOne = true;");
      contigs.addContig(contig);
    }
  }

  private boolean loadAS(String s, AceContigArr res) {
    StringTokenizer tokens = new StringTokenizer(s, " \t", false);
    if (tokens.countTokens() != AS_N_TOKENS) {
      String error = "Expecting \nAS <number of contigs> <total number of reads in ace file>";
      log.error(error);
      JOptionPane.showMessageDialog(null, error);
      return false;
    }
    String typeCode = tokens.nextToken().trim();
    String nContigs = tokens.nextToken().trim();
    String nReads = tokens.nextToken().trim();
    try {
      res.setNumContigs(Integer.parseInt(nContigs));
      res.setNumReads(Integer.parseInt(nReads));
    } catch (NumberFormatException e) {
      String error = e.toString() + "\n while parsing tokens typeCode='"
        + typeCode + "', nContigs='" + nContigs + "', nReads='" + nReads +"'";
      log.error(error);
      JOptionPane.showMessageDialog(null, error);
      return false;
    }
    return true;
  }
  private boolean loadContig(String s, AceContig res) {
    StringTokenizer tokens = new StringTokenizer(s, " \t", false);
    if (tokens.countTokens() != CONTIG_N_TOKENS) {
      String error = "Expecting \nCO <contig name> <# of bases> <# of reads in contig> <# of base segments in contig> <U or C>";
      log.error(error);
      JOptionPane.showMessageDialog(null, error);
      return false;
    }
    String typeCode = tokens.nextToken().trim();
    String name = tokens.nextToken().trim();

//    if (name.equals("Contig99")) {
//      int dbg = 1;
//    }
    res.setId(name);
    String nBases = tokens.nextToken().trim();
    String nReads = tokens.nextToken().trim();
    String nBaseSegments = tokens.nextToken().trim();
    String ucCode = tokens.nextToken().trim();        // ignore
    try {
      res.setNumBases(Integer.parseInt(nBases));
      res.setNumReads(Integer.parseInt(nReads));
      res.setNumSegments(Integer.parseInt(nBaseSegments));
    } catch (NumberFormatException e) {
      String error = e.toString() + "\n while parsing tokens typeCode='" + typeCode
        + "', \nname='" + name
        + "', \nnBases='" + nBases
        + "', \nnReads='" + nReads
        + "', \nnBaseSegments='" + nBaseSegments
        + "', \nucCode='" + ucCode
        +"'";
      log.error(error);
      JOptionPane.showMessageDialog(null, error);
      return false;
    }
    return true;
  }
  private boolean loadRead(String s, AceRead res) {
    StringTokenizer tokens = new StringTokenizer(s, " \t", false);
    if (tokens.countTokens() != READ_N_TOKENS) {
      String error = "Expecting \nRD <read name> <# of padded bases> <# of whole read info items> <# of read tags>";
      log.error(error);
      JOptionPane.showMessageDialog(null, error);
      return false;
    }
    String typeCode = tokens.nextToken().trim();
    String name = tokens.nextToken().trim();

//    if (name.equals("495806_2812_3610")) {
//      int dbg = 1;
//    }

    res.setId(name);
    String nBases = tokens.nextToken().trim();
    String nInfoItems = tokens.nextToken().trim();
    String nTags = tokens.nextToken().trim();
    try {
      res.setNumBases(Integer.parseInt(nBases));
      res.setNumInfoItems(Integer.parseInt(nInfoItems));
      res.setNumTags(Integer.parseInt(nTags));
    } catch (NumberFormatException e) {
      String error = e.toString() + "\n while parsing tokens typeCode='" + typeCode
        + "', \nname='" + name
        + "', \nnBases='" + nBases
        + "', \nnInfoItems='" + nInfoItems
        + "', \nnTags='" + nTags
        +"'";
      log.error(error);
      JOptionPane.showMessageDialog(null, error);
      return false;
    }
    return true;
  }
  private boolean loadReadQA(String s, AceRead res) {
    StringTokenizer tokens = new StringTokenizer(s, " \t", false);
    if (tokens.countTokens() != READ_QA_N_TOKENS) {
      String error = "Expecting \nQA <qual clipping start> <qual clipping end> <align clipping start> <align clipping end>";
      log.error(error);
      JOptionPane.showMessageDialog(null, error);
      return false;
    }
    String typeCode = tokens.nextToken().trim();
    String qltyStart = tokens.nextToken().trim();
    String qltyEnd = tokens.nextToken().trim();
    String alignStart = tokens.nextToken().trim();
    String alignEnd = tokens.nextToken().trim();
    try {
      res.setQltyStart(Integer.parseInt(qltyStart));
      res.setQltyEnd(Integer.parseInt(qltyEnd));
      res.setAlignStart(Integer.parseInt(alignStart));
      res.setAlignEnd(Integer.parseInt(alignEnd));
    } catch (NumberFormatException e) {
      String error = e.toString() + "\n while parsing tokens typeCode='" + typeCode
        + "', \nqltyStart='" + qltyStart
        + "', \nqltyEnd='" + qltyEnd
        + "', \nalignStart='" + alignStart
        + "', \nalignEnd='" + alignEnd
        +"'";
      log.error(error);
      JOptionPane.showMessageDialog(null, error);
      return false;
    }
    return true;
  }
  private boolean loadAF(String s, AceContig contig) {
    StringTokenizer tokens = new StringTokenizer(s, " \t", false);
    if (tokens.countTokens() != AF_N_TOKENS) {
      String error = "Expecting \nAF <read name> <C or U> <padded start consensus position>";
      log.error(error);
      JOptionPane.showMessageDialog(null, error);
      return false;
    }
    String typeCode = tokens.nextToken().trim();        log.dbg("typeCode=", typeCode);
    String readName = tokens.nextToken().trim();        log.dbg("readName=", readName);
    AceReadAssem res = new AceReadAssem(readName);
    String ucCode = tokens.nextToken().trim();          log.dbg("ucCode=", ucCode);
    res.setComplemented(ucCode.equals(AF_C_CODE));
    String startPos = tokens.nextToken().trim();        log.dbg("startPos=", startPos);
    try {
      res.setStartPos(Integer.parseInt(startPos));

      if (res.getStartPos() <= 0) {
        int dgb = 1;
      }

      contig.addAssem(res);
    } catch (NumberFormatException e) {
      String error = e.toString() + "\n while parsing tokens typeCode='" + typeCode
        + "', \nreadName='" + readName
        + "', \nucCode='" + ucCode
        + "', \nstartPos='" + startPos
        +"'";
      log.error(error);
      JOptionPane.showMessageDialog(null, error);
      return false;
    }
    return true;
  }
  private boolean loadBS(String s, AceContig contig) {
    return true;
  }
  private boolean loadReadDS(String s, AceRead res) {
    return true;
  }
}
